= Lua CJSON 1.0devel Manual =
Mark Pulford <mark@kyne.com.au>
:revdate: 30th November 2011

Overview
--------

Lua CJSON provides fast JSON parsing and encoding support for Lua.

.Features
- More than 10x to 20x faster than the efficient pure Lua JSON modules.
- Full support for JSON with UTF-8, including decoding surrogate
  pairs.
- Optional run-time support for common exceptions to the JSON
  specification (NaN, Inf,..).

.Caveats
- UTF-16 and UTF-32 are not supported.
- Multi-threading within a single Lua state is not supported.
  However, this is not a recommended configuration under Lua.

Lua CJSON is covered by the MIT license. See the file +LICENSE+ for
details.

The latest version of this software is available from the 
http://www.kyne.com.au/~mark/software/lua-cjson.php[Lua CJSON website].

Feel free to email me if you have any patches, suggestions, or
comments.


Installation Methods
--------------------

Lua CJSON requires either http://www.lua.org[Lua] or
http://www.luajit.org[LuaJIT] to build.

There are 3 build methods available:

Make::
  POSIX (including Linux, BSD, Mac OSX & Solaris)
RPM::
  Linux
LuaRocks::
  POSIX (including Linux, BSD, Mac OSX & Solaris), Windows


Build options (#define)
~~~~~~~~~~~~~~~~~~~~~~~

Lua CJSON uses +strtod+(3) and +snprintf+(3) to perform numeric
conversion as they are usually well supported, fast and bug free. To
ensure JSON encoding/decoding works correctly for locales using comma
decimal separators, Lua CJSON may optionally be compiled with one of
the following (+#define+):

USE_POSIX_USELOCALE::
  Thread safe. Supported by Linux and Mac OSX. Recommended where available.
USE_POSIX_SETLOCALE::
  Works on all ANSI C platforms. Only use with single threaded programs.

Also available:

USE_INTERNAL_ISINF::
  Workaround for Solaris platforms missing isinf().


Make
~~~~

Review and update the included Makefile to suit your platform. Next,
build and install the module:

[source,sh]
make install

Or install manually:

[source,sh]
make
cp cjson.so $your_lua_module_directory


RPM
~~~

Linux distributions using RPM should be able to create a package via
the included RPM spec file. Install the +rpm-build+ package (or
similar) then:

[source,sh]
rpmbuild -tb lua-cjson-1.0devel.tar.gz
rpm -Uvh $newly_built_lua_cjson_rpm


LuaRocks
~~~~~~~~

http://luarocks.org[LuaRocks] can be used to install and manage Lua
modules on a wide range of platforms (including Windows).

Extract the Lua CJSON source package into a directory and run:

[source,sh]
cd lua-cjson-1.0devel
luarocks make

[NOTE]
LuaRocks does not support platform specific configuration for Solaris.
On Solaris, you may need to manually uncomment +USE_INTERNAL_ISINF+ in
the rockspec before building this module.

See the http://luarocks.org/en/Documentation[LuaRocks documentation] for
further details.


API (Functions)
---------------

Synopsis
~~~~~~~~

[source,lua]
------------
require "cjson"
-- Or:
local cjson = require "cjson"
 
-- Translate Lua value to/from JSON
text = cjson.encode(value)
value = cjson.decode(text)
 
-- Get and/or set Lua CJSON configuration
setting = cjson.refuse_invalid_numbers([setting])
depth = cjson.encode_max_depth([depth])
convert, ratio, safe = cjson.encode_sparse_array([convert[, ratio[, safe]]])
keep = cjson.encode_keep_buffer([keep])
------------


cjson.decode
~~~~~~~~~~~~

[source,lua]
------------
value = cjson.decode(json_text)
------------

+cjson.decode+ will deserialise any UTF-8 JSON string into a Lua value
or table. It may return any of the types that +cjson.encode+ supports.

UTF-16 and UTF-32 JSON strings are not supported.

+cjson.decode+ requires that any NULL (ASCII 0) and double quote
(ASCII 34) characters are escaped within strings. All escape codes
will be decoded and other characters will be passed transparently.
UTF-8 characters are not validated during decoding and should be
checked elsewhere if required.

JSON +null+ will be converted to a NULL +lightuserdata+ value. This
can be compared with +cjson.null+ for convenience.

By default, _invalid_ numbers (NaN, Infinity, Hexidecimal) will be
decoded. This default can be changed with
+cjson.refuse_invalid_numbers+.

.Example: Decoding
[source,lua]
json_text = '[ true, { "foo": "bar" } ]'
value = cjson.decode(json_text)
-- Returns: { true, { foo = "bar" } }

[CAUTION]
Care must be taken when after decoding JSON objects with numeric keys. Each
numeric key will be stored as a Lua +string+. Any code assuming type
+number+ may break.


cjson.encode
~~~~~~~~~~~~

[source,lua]
------------
json_text = cjson.encode(value)
------------

+cjson.encode+ will serialise a Lua value into a string containing the
JSON representation.

+cjson.encode+ supports the following types:

- +boolean+
- +lightuserdata+ (NULL value only)
- +nil+
- +number+
- +string+
- +table+

The remaining Lua types will generate an error:

- +function+
- +lightuserdata+ (non-NULL values)
- +thread+
- +userdata+

Numbers are encoded using the standard Lua number format.

Lua CJSON will escape the following characters within each string:

- Control characters (ASCII 0 - 31)
- Double quote (ASCII 34)
- Forward slash (ASCII 47)
- Blackslash (ASCII 92)
- Delete (ASCII 127)

All other characters are passed transparently. Any UTF-8 error
checking must be done by the application.

Lua CJSON uses a heuristic to determine whether to encode a Lua table
as a JSON array or an object. A Lua table which only has positive
integers (>0) keys of type +number+ will be encoded as a JSON array.
All other tables will be encoded as a JSON object.

Missing entries from sparse Lua arrays are encoded as +null+.

.Example: Encoding a sparse array
[source,lua]
cjson.encode({ [3] = "data" })
-- Returns: '[null,null,"data"]'

Lua CJSON does not use metamethods when serialising tables.

- +rawget+ is used to iterate over Lua arrays.
- +next+ is used to iterate over Lua objects.

JSON object keys are always strings. +cjson.encode+ can only handle
table keys which are type +number+ or +string+. All other types will
generate an error.


[NOTE]
Standards compliant JSON must be encapsulated in either an
object (+{}+) or an array (+[]+). Hence a table must be passed to
+cjson.encode+ to generate standards compliant JSON output.

By default, the following will generate errors:

- Excessively <<sparse_arrays,sparse arrays>>
- More than 20 nested tables
- Invalid numbers (NaN, Infinity)

These defaults can be changed with:

- +cjson.encode_sparse_array+
- +cjson.encode_max_depth+
- +cjson.refuse_invalid_numbers+

.Example: encoding
[source,lua]
value = { true, { foo = "bar" } }
json_text = cjson.encode(value)
-- Returns: '[true,{"foo":"bar"}]'


cjson.encode_max_depth
~~~~~~~~~~~~~~~~~~~~~~

[source,lua]
------------
depth = cjson.encode_max_depth([depth])
-- "depth" must be a positive integer (>0).
------------

By default, Lua CJSON will reject data structure with more than 20 nested
tables.

This check prevents a deeply nested or recursive data structure from
crashing the application.

.Example: Recursive Lua tables
[source,lua]
a = {}; b = { a }; a[1] = b

Once the maximum table depth has been reached Lua CJSON will throw an error.


cjson.encode_number_precision
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[source,lua]
------------
precision = cjson.encode_number_precision([precision])
-- "precision" must be between 1 and 14 (inclusive)
------------

By default, Lua CJSON will output 14 significant digits when
converting a number to text.

Reducing number precision to _3_ can improve performance of number
heavy JSON conversions by up to 50%.


[[sparse_arrays]]
cjson.encode_sparse_array
~~~~~~~~~~~~~~~~~~~~~~~~~

[source,lua]
------------
convert, ratio, safe = cjson.encode_sparse_array([convert[, ratio[, safe]]])
-- "convert" must be a boolean. Default: false.
-- "ratio" must be a positive integer (>0). Default: 2
-- "safe" must be a positive integer (>0). Default: 10
------------

Lua CJSON classifies Lua tables into 3 types when encoding as a JSON
array. This is determined by the number of values missing for keys up
to the maximum index:

Normal::
  All values are available.
Sparse::
  At least 1 value is missing.
Excessively sparse::
  The number of missing values exceed a configured number.

Lua CJSON encodes sparse Lua arrays by as JSON arrays using JSON +null+.

.Example: Encoding a sparse array
[source,lua]
cjson.encode({ [3] = "sparse" })
-- Returns: '[null,null,"sparse"]'

Lua CJSON checks for excessively sparse arrays when the maximum index
is greater an the +safe+ limit and +ratio+ is greater than +0+. An
array is _excessively sparse_ when:

_maximum_index_ > _item_count_ * +ratio+

By default, attempting to encode excessively sparse arrays will
generate an error. If +convert+ is set to +true+, excessively sparse
arrays will be converted to a JSON object:

.Example: Enabling conversion to a JSON object
[source,lua]
cjson.encode_sparse_array(true)
cjson.encode({ [1000] = "excessively sparse" })
-- Returns: '{"1000":"excessively sparse"}'


cjson.keep_encode_buffer
~~~~~~~~~~~~~~~~~~~~~~~~

[source,lua]
------------
keep = cjson.keep_encode_buffer([keep])
-- "keep" must be a boolean
------------

By default, Lua CJSON will reuse the JSON encoding buffer to improve
performance. The buffer will grow to the largest size required and is
not freed until the Lua CJSON module is garbage collected. Setting this
option to +false+ will cause the buffer to be freed after each call to
+cjson.encode+.


cjson.refuse_invalid_numbers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[source,lua]
------------
setting = cjson.refuse_invalid_numbers([setting])
-- "setting" must be on of:
--       false, "encode", "decode", "both", true
------------

Lua CJSON considers numbers which are outside the JSON specification to be
_invalid_:

- Infinity
- NaN
- Hexadecimal numbers

By default Lua CJSON will decode _invalid_ numbers, but will refuse to
encode them.

This setting can be configured separately for encoding and/or
decoding:

Enabled::
  an error will be generated if an _invalid_ number is found.
Disabled (encoding)::
  NaN and Infinity can be encoded.
Disabled (decoding)::
  All numbers supported by +strtod+(3) will be parsed.


API (Variables)
---------------

cjson.null
~~~~~~~~~~

Lua CJSON decodes JSON +null+ as a Lua lightuserdata NULL pointer.
+cjson.null+ can be used for comparison.


cjson.version
~~~~~~~~~~~~~

The version number of the Lua CJSON module in use can be found in
+cjson.version+.


[sect1]
References
----------

- http://tools.ietf.org/html/rfc4627[RFC 4627]
- http://www.json.org/[JSON website]
